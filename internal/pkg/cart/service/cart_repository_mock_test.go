// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package service

//go:generate minimock -i ProductCartService/internal/pkg/cart/service.CartRepository -o cart_repository_mock_test.go -n CartRepositoryMock -p service

import (
	"ProductCartService/internal/pkg/cart/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddProduct          func(userID int64, sku int64, count uint16) (err error)
	funcAddProductOrigin    string
	inspectFuncAddProduct   func(userID int64, sku int64, count uint16)
	afterAddProductCounter  uint64
	beforeAddProductCounter uint64
	AddProductMock          mCartRepositoryMockAddProduct

	funcClearCart          func(userID int64) (err error)
	funcClearCartOrigin    string
	inspectFuncClearCart   func(userID int64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCartRepositoryMockClearCart

	funcDeleteProduct          func(userID int64, sku int64) (err error)
	funcDeleteProductOrigin    string
	inspectFuncDeleteProduct   func(userID int64, sku int64)
	afterDeleteProductCounter  uint64
	beforeDeleteProductCounter uint64
	DeleteProductMock          mCartRepositoryMockDeleteProduct

	funcGetCart          func(userID int64) (cp1 *model.Cart, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(userID int64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart
}

// NewCartRepositoryMock returns a mock for CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddProductMock = mCartRepositoryMockAddProduct{mock: m}
	m.AddProductMock.callArgs = []*CartRepositoryMockAddProductParams{}

	m.ClearCartMock = mCartRepositoryMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CartRepositoryMockClearCartParams{}

	m.DeleteProductMock = mCartRepositoryMockDeleteProduct{mock: m}
	m.DeleteProductMock.callArgs = []*CartRepositoryMockDeleteProductParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddProduct struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddProductExpectation
	expectations       []*CartRepositoryMockAddProductExpectation

	callArgs []*CartRepositoryMockAddProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockAddProductExpectation specifies expectation struct of the CartRepository.AddProduct
type CartRepositoryMockAddProductExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockAddProductParams
	paramPtrs          *CartRepositoryMockAddProductParamPtrs
	expectationOrigins CartRepositoryMockAddProductExpectationOrigins
	results            *CartRepositoryMockAddProductResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockAddProductParams contains parameters of the CartRepository.AddProduct
type CartRepositoryMockAddProductParams struct {
	userID int64
	sku    int64
	count  uint16
}

// CartRepositoryMockAddProductParamPtrs contains pointers to parameters of the CartRepository.AddProduct
type CartRepositoryMockAddProductParamPtrs struct {
	userID *int64
	sku    *int64
	count  *uint16
}

// CartRepositoryMockAddProductResults contains results of the CartRepository.AddProduct
type CartRepositoryMockAddProductResults struct {
	err error
}

// CartRepositoryMockAddProductOrigins contains origins of expectations of the CartRepository.AddProduct
type CartRepositoryMockAddProductExpectationOrigins struct {
	origin       string
	originUserID string
	originSku    string
	originCount  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddProduct *mCartRepositoryMockAddProduct) Optional() *mCartRepositoryMockAddProduct {
	mmAddProduct.optional = true
	return mmAddProduct
}

// Expect sets up expected params for CartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) Expect(userID int64, sku int64, count uint16) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.paramPtrs != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by ExpectParams functions")
	}

	mmAddProduct.defaultExpectation.params = &CartRepositoryMockAddProductParams{userID, sku, count}
	mmAddProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddProduct.expectations {
		if minimock.Equal(e.params, mmAddProduct.defaultExpectation.params) {
			mmAddProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddProduct.defaultExpectation.params)
		}
	}

	return mmAddProduct
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) ExpectUserIDParam1(userID int64) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.userID = &userID
	mmAddProduct.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectSkuParam2 sets up expected param sku for CartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) ExpectSkuParam2(sku int64) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.sku = &sku
	mmAddProduct.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectCountParam3 sets up expected param count for CartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) ExpectCountParam3(count uint16) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.count = &count
	mmAddProduct.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmAddProduct
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) Inspect(f func(userID int64, sku int64, count uint16)) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.inspectFuncAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddProduct")
	}

	mmAddProduct.mock.inspectFuncAddProduct = f

	return mmAddProduct
}

// Return sets up results that will be returned by CartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) Return(err error) *CartRepositoryMock {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{mock: mmAddProduct.mock}
	}
	mmAddProduct.defaultExpectation.results = &CartRepositoryMockAddProductResults{err}
	mmAddProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// Set uses given function f to mock the CartRepository.AddProduct method
func (mmAddProduct *mCartRepositoryMockAddProduct) Set(f func(userID int64, sku int64, count uint16) (err error)) *CartRepositoryMock {
	if mmAddProduct.defaultExpectation != nil {
		mmAddProduct.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddProduct method")
	}

	if len(mmAddProduct.expectations) > 0 {
		mmAddProduct.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddProduct method")
	}

	mmAddProduct.mock.funcAddProduct = f
	mmAddProduct.mock.funcAddProductOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// When sets expectation for the CartRepository.AddProduct which will trigger the result defined by the following
// Then helper
func (mmAddProduct *mCartRepositoryMockAddProduct) When(userID int64, sku int64, count uint16) *CartRepositoryMockAddProductExpectation {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddProductExpectation{
		mock:               mmAddProduct.mock,
		params:             &CartRepositoryMockAddProductParams{userID, sku, count},
		expectationOrigins: CartRepositoryMockAddProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddProduct.expectations = append(mmAddProduct.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddProduct return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddProductExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddProductResults{err}
	return e.mock
}

// Times sets number of times CartRepository.AddProduct should be invoked
func (mmAddProduct *mCartRepositoryMockAddProduct) Times(n uint64) *mCartRepositoryMockAddProduct {
	if n == 0 {
		mmAddProduct.mock.t.Fatalf("Times of CartRepositoryMock.AddProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddProduct.expectedInvocations, n)
	mmAddProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddProduct
}

func (mmAddProduct *mCartRepositoryMockAddProduct) invocationsDone() bool {
	if len(mmAddProduct.expectations) == 0 && mmAddProduct.defaultExpectation == nil && mmAddProduct.mock.funcAddProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddProduct.mock.afterAddProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddProduct implements CartRepository
func (mmAddProduct *CartRepositoryMock) AddProduct(userID int64, sku int64, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddProduct.beforeAddProductCounter, 1)
	defer mm_atomic.AddUint64(&mmAddProduct.afterAddProductCounter, 1)

	mmAddProduct.t.Helper()

	if mmAddProduct.inspectFuncAddProduct != nil {
		mmAddProduct.inspectFuncAddProduct(userID, sku, count)
	}

	mm_params := CartRepositoryMockAddProductParams{userID, sku, count}

	// Record call args
	mmAddProduct.AddProductMock.mutex.Lock()
	mmAddProduct.AddProductMock.callArgs = append(mmAddProduct.AddProductMock.callArgs, &mm_params)
	mmAddProduct.AddProductMock.mutex.Unlock()

	for _, e := range mmAddProduct.AddProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddProduct.AddProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddProduct.AddProductMock.defaultExpectation.Counter, 1)
		mm_want := mmAddProduct.AddProductMock.defaultExpectation.params
		mm_want_ptrs := mmAddProduct.AddProductMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddProductParams{userID, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddProduct.AddProductMock.defaultExpectation.results
		if mm_results == nil {
			mmAddProduct.t.Fatal("No results are set for the CartRepositoryMock.AddProduct")
		}
		return (*mm_results).err
	}
	if mmAddProduct.funcAddProduct != nil {
		return mmAddProduct.funcAddProduct(userID, sku, count)
	}
	mmAddProduct.t.Fatalf("Unexpected call to CartRepositoryMock.AddProduct. %v %v %v", userID, sku, count)
	return
}

// AddProductAfterCounter returns a count of finished CartRepositoryMock.AddProduct invocations
func (mmAddProduct *CartRepositoryMock) AddProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.afterAddProductCounter)
}

// AddProductBeforeCounter returns a count of CartRepositoryMock.AddProduct invocations
func (mmAddProduct *CartRepositoryMock) AddProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.beforeAddProductCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddProduct *mCartRepositoryMockAddProduct) Calls() []*CartRepositoryMockAddProductParams {
	mmAddProduct.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddProductParams, len(mmAddProduct.callArgs))
	copy(argCopy, mmAddProduct.callArgs)

	mmAddProduct.mutex.RUnlock()

	return argCopy
}

// MinimockAddProductDone returns true if the count of the AddProduct invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddProductDone() bool {
	if m.AddProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddProductMock.invocationsDone()
}

// MinimockAddProductInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddProductInspect() {
	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddProductCounter := mm_atomic.LoadUint64(&m.afterAddProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductMock.defaultExpectation != nil && afterAddProductCounter < 1 {
		if m.AddProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.AddProduct at\n%s", m.AddProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddProduct at\n%s with params: %#v", m.AddProductMock.defaultExpectation.expectationOrigins.origin, *m.AddProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProduct != nil && afterAddProductCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.AddProduct at\n%s", m.funcAddProductOrigin)
	}

	if !m.AddProductMock.invocationsDone() && afterAddProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddProductMock.expectedInvocations), m.AddProductMock.expectedInvocationsOrigin, afterAddProductCounter)
	}
}

type mCartRepositoryMockClearCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockClearCartExpectation
	expectations       []*CartRepositoryMockClearCartExpectation

	callArgs []*CartRepositoryMockClearCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockClearCartExpectation specifies expectation struct of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockClearCartParams
	paramPtrs          *CartRepositoryMockClearCartParamPtrs
	expectationOrigins CartRepositoryMockClearCartExpectationOrigins
	results            *CartRepositoryMockClearCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockClearCartParams contains parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParams struct {
	userID int64
}

// CartRepositoryMockClearCartParamPtrs contains pointers to parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParamPtrs struct {
	userID *int64
}

// CartRepositoryMockClearCartResults contains results of the CartRepository.ClearCart
type CartRepositoryMockClearCartResults struct {
	err error
}

// CartRepositoryMockClearCartOrigins contains origins of expectations of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCart *mCartRepositoryMockClearCart) Optional() *mCartRepositoryMockClearCart {
	mmClearCart.optional = true
	return mmClearCart
}

// Expect sets up expected params for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Expect(userID int64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.paramPtrs != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by ExpectParams functions")
	}

	mmClearCart.defaultExpectation.params = &CartRepositoryMockClearCartParams{userID}
	mmClearCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectUserIDParam1(userID int64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.userID = &userID
	mmClearCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Inspect(f func(userID int64)) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Return(err error) *CartRepositoryMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CartRepositoryMockClearCartResults{err}
	mmClearCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// Set uses given function f to mock the CartRepository.ClearCart method
func (mmClearCart *mCartRepositoryMockClearCart) Set(f func(userID int64) (err error)) *CartRepositoryMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	mmClearCart.mock.funcClearCartOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// When sets expectation for the CartRepository.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCartRepositoryMockClearCart) When(userID int64) *CartRepositoryMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockClearCartExpectation{
		mock:               mmClearCart.mock,
		params:             &CartRepositoryMockClearCartParams{userID},
		expectationOrigins: CartRepositoryMockClearCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ClearCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockClearCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.ClearCart should be invoked
func (mmClearCart *mCartRepositoryMockClearCart) Times(n uint64) *mCartRepositoryMockClearCart {
	if n == 0 {
		mmClearCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCart.expectedInvocations, n)
	mmClearCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCart
}

func (mmClearCart *mCartRepositoryMockClearCart) invocationsDone() bool {
	if len(mmClearCart.expectations) == 0 && mmClearCart.defaultExpectation == nil && mmClearCart.mock.funcClearCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCart.mock.afterClearCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCart implements CartRepository
func (mmClearCart *CartRepositoryMock) ClearCart(userID int64) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	mmClearCart.t.Helper()

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(userID)
	}

	mm_params := CartRepositoryMockClearCartParams{userID}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, &mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearCart.ClearCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockClearCartParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CartRepositoryMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(userID)
	}
	mmClearCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearCart. %v", userID)
	return
}

// ClearCartAfterCounter returns a count of finished CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCartRepositoryMockClearCart) Calls() []*CartRepositoryMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearCartDone() bool {
	if m.ClearCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartMock.invocationsDone()
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartCounter := mm_atomic.LoadUint64(&m.afterClearCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && afterClearCartCounter < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.ClearCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", m.ClearCartMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && afterClearCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.funcClearCartOrigin)
	}

	if !m.ClearCartMock.invocationsDone() && afterClearCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartMock.expectedInvocations), m.ClearCartMock.expectedInvocationsOrigin, afterClearCartCounter)
	}
}

type mCartRepositoryMockDeleteProduct struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteProductExpectation
	expectations       []*CartRepositoryMockDeleteProductExpectation

	callArgs []*CartRepositoryMockDeleteProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteProductExpectation specifies expectation struct of the CartRepository.DeleteProduct
type CartRepositoryMockDeleteProductExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteProductParams
	paramPtrs          *CartRepositoryMockDeleteProductParamPtrs
	expectationOrigins CartRepositoryMockDeleteProductExpectationOrigins
	results            *CartRepositoryMockDeleteProductResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteProductParams contains parameters of the CartRepository.DeleteProduct
type CartRepositoryMockDeleteProductParams struct {
	userID int64
	sku    int64
}

// CartRepositoryMockDeleteProductParamPtrs contains pointers to parameters of the CartRepository.DeleteProduct
type CartRepositoryMockDeleteProductParamPtrs struct {
	userID *int64
	sku    *int64
}

// CartRepositoryMockDeleteProductResults contains results of the CartRepository.DeleteProduct
type CartRepositoryMockDeleteProductResults struct {
	err error
}

// CartRepositoryMockDeleteProductOrigins contains origins of expectations of the CartRepository.DeleteProduct
type CartRepositoryMockDeleteProductExpectationOrigins struct {
	origin       string
	originUserID string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) Optional() *mCartRepositoryMockDeleteProduct {
	mmDeleteProduct.optional = true
	return mmDeleteProduct
}

// Expect sets up expected params for CartRepository.DeleteProduct
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) Expect(userID int64, sku int64) *mCartRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartRepositoryMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by ExpectParams functions")
	}

	mmDeleteProduct.defaultExpectation.params = &CartRepositoryMockDeleteProductParams{userID, sku}
	mmDeleteProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteProduct.expectations {
		if minimock.Equal(e.params, mmDeleteProduct.defaultExpectation.params) {
			mmDeleteProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProduct.defaultExpectation.params)
		}
	}

	return mmDeleteProduct
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.DeleteProduct
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) ExpectUserIDParam1(userID int64) *mCartRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartRepositoryMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteProduct.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// ExpectSkuParam2 sets up expected param sku for CartRepository.DeleteProduct
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) ExpectSkuParam2(sku int64) *mCartRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartRepositoryMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.sku = &sku
	mmDeleteProduct.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteProduct
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) Inspect(f func(userID int64, sku int64)) *mCartRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteProduct")
	}

	mmDeleteProduct.mock.inspectFuncDeleteProduct = f

	return mmDeleteProduct
}

// Return sets up results that will be returned by CartRepository.DeleteProduct
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) Return(err error) *CartRepositoryMock {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartRepositoryMockDeleteProductExpectation{mock: mmDeleteProduct.mock}
	}
	mmDeleteProduct.defaultExpectation.results = &CartRepositoryMockDeleteProductResults{err}
	mmDeleteProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// Set uses given function f to mock the CartRepository.DeleteProduct method
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) Set(f func(userID int64, sku int64) (err error)) *CartRepositoryMock {
	if mmDeleteProduct.defaultExpectation != nil {
		mmDeleteProduct.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteProduct method")
	}

	if len(mmDeleteProduct.expectations) > 0 {
		mmDeleteProduct.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteProduct method")
	}

	mmDeleteProduct.mock.funcDeleteProduct = f
	mmDeleteProduct.mock.funcDeleteProductOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// When sets expectation for the CartRepository.DeleteProduct which will trigger the result defined by the following
// Then helper
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) When(userID int64, sku int64) *CartRepositoryMockDeleteProductExpectation {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartRepositoryMock.DeleteProduct mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteProductExpectation{
		mock:               mmDeleteProduct.mock,
		params:             &CartRepositoryMockDeleteProductParams{userID, sku},
		expectationOrigins: CartRepositoryMockDeleteProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteProduct.expectations = append(mmDeleteProduct.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteProduct return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteProductExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteProductResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteProduct should be invoked
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) Times(n uint64) *mCartRepositoryMockDeleteProduct {
	if n == 0 {
		mmDeleteProduct.mock.t.Fatalf("Times of CartRepositoryMock.DeleteProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteProduct.expectedInvocations, n)
	mmDeleteProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct
}

func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) invocationsDone() bool {
	if len(mmDeleteProduct.expectations) == 0 && mmDeleteProduct.defaultExpectation == nil && mmDeleteProduct.mock.funcDeleteProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.mock.afterDeleteProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteProduct implements CartRepository
func (mmDeleteProduct *CartRepositoryMock) DeleteProduct(userID int64, sku int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteProduct.beforeDeleteProductCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProduct.afterDeleteProductCounter, 1)

	mmDeleteProduct.t.Helper()

	if mmDeleteProduct.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.inspectFuncDeleteProduct(userID, sku)
	}

	mm_params := CartRepositoryMockDeleteProductParams{userID, sku}

	// Record call args
	mmDeleteProduct.DeleteProductMock.mutex.Lock()
	mmDeleteProduct.DeleteProductMock.callArgs = append(mmDeleteProduct.DeleteProductMock.callArgs, &mm_params)
	mmDeleteProduct.DeleteProductMock.mutex.Unlock()

	for _, e := range mmDeleteProduct.DeleteProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteProduct.DeleteProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProduct.DeleteProductMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProduct.DeleteProductMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteProduct.DeleteProductMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteProductParams{userID, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteProduct.t.Errorf("CartRepositoryMock.DeleteProduct got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmDeleteProduct.t.Errorf("CartRepositoryMock.DeleteProduct got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProduct.t.Errorf("CartRepositoryMock.DeleteProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteProduct.DeleteProductMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteProduct.t.Fatal("No results are set for the CartRepositoryMock.DeleteProduct")
		}
		return (*mm_results).err
	}
	if mmDeleteProduct.funcDeleteProduct != nil {
		return mmDeleteProduct.funcDeleteProduct(userID, sku)
	}
	mmDeleteProduct.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteProduct. %v %v", userID, sku)
	return
}

// DeleteProductAfterCounter returns a count of finished CartRepositoryMock.DeleteProduct invocations
func (mmDeleteProduct *CartRepositoryMock) DeleteProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.afterDeleteProductCounter)
}

// DeleteProductBeforeCounter returns a count of CartRepositoryMock.DeleteProduct invocations
func (mmDeleteProduct *CartRepositoryMock) DeleteProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.beforeDeleteProductCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProduct *mCartRepositoryMockDeleteProduct) Calls() []*CartRepositoryMockDeleteProductParams {
	mmDeleteProduct.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteProductParams, len(mmDeleteProduct.callArgs))
	copy(argCopy, mmDeleteProduct.callArgs)

	mmDeleteProduct.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteProductDone returns true if the count of the DeleteProduct invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteProductDone() bool {
	if m.DeleteProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteProductMock.invocationsDone()
}

// MinimockDeleteProductInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteProductInspect() {
	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteProductCounter := mm_atomic.LoadUint64(&m.afterDeleteProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteProductMock.defaultExpectation != nil && afterDeleteProductCounter < 1 {
		if m.DeleteProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteProduct at\n%s", m.DeleteProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteProduct at\n%s with params: %#v", m.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *m.DeleteProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProduct != nil && afterDeleteProductCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteProduct at\n%s", m.funcDeleteProductOrigin)
	}

	if !m.DeleteProductMock.invocationsDone() && afterDeleteProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteProductMock.expectedInvocations), m.DeleteProductMock.expectedInvocationsOrigin, afterDeleteProductCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartParams
	paramPtrs          *CartRepositoryMockGetCartParamPtrs
	expectationOrigins CartRepositoryMockGetCartExpectationOrigins
	results            *CartRepositoryMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartParams contains parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	userID int64
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	userID *int64
}

// CartRepositoryMockGetCartResults contains results of the CartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	cp1 *model.Cart
	err error
}

// CartRepositoryMockGetCartOrigins contains origins of expectations of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(userID int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{userID}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectUserIDParam1 sets up expected param userID for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectUserIDParam1(userID int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userID = &userID
	mmGetCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(userID int64)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(cp1 *model.Cart, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{cp1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(userID int64) (cp1 *model.Cart, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(userID int64) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartRepositoryMockGetCartParams{userID},
		expectationOrigins: CartRepositoryMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(cp1 *model.Cart, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements CartRepository
func (mmGetCart *CartRepositoryMock) GetCart(userID int64) (cp1 *model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(userID)
	}

	mm_params := CartRepositoryMockGetCartParams{userID}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(userID)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v", userID)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddProductInspect()

			m.MinimockClearCartInspect()

			m.MinimockDeleteProductInspect()

			m.MinimockGetCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddProductDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockDeleteProductDone() &&
		m.MinimockGetCartDone()
}
